[
{
	"uri": "https://nray-scanner.org/",
	"title": "nray",
	"tags": [],
	"description": "",
	"content": "nray Welcome to the home page of nray, a free, modern, platform independent and distributed network scanner. New to nray? Read the introduction to get started.\nSearching for the latest releases or information on how to build your own? The installation chapter answers all your questions.\nAlready got everything in place? Usage describes general usage as well as configuration and advanced tricks to get most out of nray!\nGot hooked? Having problems? The documentation lacks information. YOU can help? Join the team and shape the next generation of network discovery!\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/targetgenerator/standard/",
	"title": "standard",
	"tags": [],
	"description": "",
	"content": "This is the standard target generator that is probably going to be used most of the time. It takes a list of IPs, CIDR networks or domain names as targets and black list as well as a list of TCP and UDP ports to be scanned.\nenabled: true Enables or disables this target generator.\ntargets: [] A list of targets to scan. May be (also a mix of) CIDR networks, IPs or domain names.\nExample:\nstandard: enabled: true targets: [\u0026#34;192.168.1.1/24\u0026#34;, \u0026#34;192.168.16.0/22\u0026#34;, \u0026#34;somesystem.domain.local\u0026#34;, \u0026#34;192.168.12.14\u0026#34;] tcpports: [\u0026#34;top25\u0026#34;] udpports: [\u0026#34;top25\u0026#34;] maxHostsPerBatch: 150 maxTcpPortsPerBatch: 25 maxUdpPortsPerBatch: 25 targetFile: \u0026quot;\u0026quot; A file containing a list of targets to scan. May be CIDR networks, IPs or domain names, newline separated.\ntcpports: [\u0026quot;top25\u0026quot;] List of TCP ports to scan. Supports enumerations ([20,21,22,23]), ranges ([8000-8100]) or nmap-style top-lists (e.g. [\u0026quot;top50\u0026quot;]). You may also mix, e.g. [20,21,22,23,8000-8100,\u0026quot;top50\u0026quot;]. Duplicates are filtered out udpports: [\u0026quot;top25\u0026quot;] List of UDP ports to scan. Supports enumerations ([20,21,22,23]), ranges ([8000-8100]) or nmap-style top-lists (e.g. [\u0026quot;top50\u0026quot;]). You may also mix, e.g. [20,21,22,23,8000-8100,\u0026quot;top50\u0026quot;]. Duplicates are filtered out blacklist: [] A list of targets not to scan. May be CIDR networks, IPs or domain names.\nDNS resolution happens at the node and there is no reverse DNS lookup. This has important implications. For example, consider example.local resolving to 10.10.10.10. When blacklisting example.local but scanning for 10.10.10.0/24, the server is going to be scanned. When blacklisting 10.10.10.0/24 but scanning for example.local, the server is going to be scanned.\n blacklistFile: \u0026quot;./blacklist.txt\u0026quot; A file containing a list of targets to scan. May be CIDR networks, IPs or domain names, newline separated.\nDNS resolution happens at the node and there is no reverse DNS lookup. This has important implications. For example, consider example.local resolving to 10.10.10.10. When blacklisting example.local but scanning for 10.10.10.0/24, the server is going to be scanned. When blacklisting 10.10.10.0/24 but scanning for example.local, the server is going to be scanned.\n maxHostsPerBatch: 150 Specifies how many target hosts are contained in a single work batch sent to a node. The higher the number, the more hosts have to be scanned by a single node before fetching new work. Should be tweaked together with maxTcpPortsPerBatch and maxUdpPortsPerBatch as well as depending on the actual requirements. You may take a look at A note on work scheduling.\nmaxTcpPortsPerBatch: 25 Specifies how many TCP ports are scheduled for a single work batch. The higher the number, the more TCP ports are scanned (if requested) before fetching new work. Should be tweaked together with maxHostsPerBatch and maxUdpPortsPerBatch as well as depending on the actual requirements. You may take a look at A note on work scheduling.\nmaxUdpPortsPerBatch: 25 Specifies how many UDP ports are scheduled for a single work batch. The higher the number, the more UDP ports are scanned (if requested) before fetching new work. Should be tweaked together with maxHostsPerBatch and maxTcpPortsPerBatch as well as depending on the actual requirements. You may take a look at A note on work scheduling.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/targetgenerator/certificatetransparency/",
	"title": "certificatetransparency",
	"tags": [],
	"description": "",
	"content": "The certificatetransparency streams data from certstream, a certificate transparency log stream. This allows to inspect all publicly issued certificates. Using this data, port scans may be issued against targets right after they obtain a certificate, usually during setup before any hardening or default password changes have been in place.\nThis may come in handy for bug bounties - nray authors BTW love to get invited for a coffee  enabled: false Enables or disables this target generator.\ndomainRegex: '^.*$' Scan every site that obtains a certificate and matches the pattern www.somethingsomething.com. The default matches every domain name, to match for example www.somethingsomething.com an expression like ^(www[.]).*([.]com)$ may be used. Since regex becomes tricky fast, this play can be adopted to see if the expression works as intended.\n  Code to try your own regular expression against a domain   package main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) var regex = \u0026#34;^(www[.]).*([.]com)$\u0026#34; var toCheck = \u0026#34;www.google.com\u0026#34; func main() { re := regexp.MustCompile(regex) fmt.Println(re.MatchString(toCheck)) }    Interesting use case ideas: Scan mail.* for open relays on port 25, check new jenkins.* instances if /script endpoint is present, or maybe there is some software out there that still uses default passwords? Endless possibilities!\ntcpports: [\u0026quot;top25\u0026quot;] List of TCP ports to scan. Supports enumerations ([20,21,22,23]), ranges ([8000-8100]) or nmap-style top-lists (e.g. [\u0026quot;top50\u0026quot;]). You may also mix, e.g. [20,21,22,23,8000-8100,\u0026quot;top50\u0026quot;]. Duplicates are filtered out udpports: [top25] List of UDP ports to scan. Supports enumerations ([20,21,22,23]), ranges ([8000-8100]) or nmap-style top-lists (e.g. [\u0026quot;top50\u0026quot;]). You may also mix, e.g. [20,21,22,23,8000-8100,\u0026quot;top50\u0026quot;]. Duplicates are filtered out blacklist: [] A list of targets not to scan. May be CIDR networks, IPs or domain names.\nDNS resolution happens at the node and there is no reverse DNS lookup. This has important implications. For example, consider example.local resolving to 10.10.10.10. When blacklisting example.local but scanning for 10.10.10.0/24, the server is going to be scanned. When blacklisting 10.10.10.0/24 but scanning for example.local, the server is going to be scanned.\n maxHostsPerBatch: 150 Specifies how many target hosts are contained in a single work batch sent to a node. The higher the number, the more hosts have to be scanned by a single node before fetching new work. Should be tweaked together with maxTcpPortsPerBatch and maxUdpPortsPerBatch as well as depending on the actual requirements. You may take a look at A note on work scheduling.\nmaxTcpPortsPerBatch: 25 Specifies how many TCP ports are scheduled for a single work batch. The higher the number, the more TCP ports are scanned (if requested) before fetching new work. Should be tweaked together with maxHostsPerBatch and maxUdpPortsPerBatch as well as depending on the actual requirements. You may take a look at A note on work scheduling.\nmaxUdpPortsPerBatch: 25 Specifies how many UDP ports are scheduled for a single work batch. The higher the number, the more UDP ports are scanned (if requested) before fetching new work. Should be tweaked together with maxHostsPerBatch and maxTcpPortsPerBatch as well as depending on the actual requirements. You may take a look at A note on work scheduling.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/targetgenerator/ldap/",
	"title": "ldap",
	"tags": [],
	"description": "",
	"content": "The ldap target generator allows to connect to a ldap server in order to identify scan targets. Especially in Active Directory environments this is really useful since computer objects have a dNSHostName property and Domain Controllers usually act also as DNS servers that can be queried via LDAP.\nenabled: false Enables or disables this target generator.\nldapSearchString: \u0026quot;(objectCategory=computer)\u0026quot; The ldap search to perform for selecting objects. In Active Directory environments, (objectCategory=computer) can be used to select all computer objects.\nbaseDN: \u0026quot;dc=contoso,dc=com\u0026quot; Base DN to start search.\nldapAttribute: \u0026quot;dNSHostName\u0026quot; On all selected objects, extract ldapAttribute. This one is going to be scanned. In Active Directory environments, chances are that dNSHostName can be resolved and is alive.\nldapServer: \u0026quot;\u0026quot; The ldapServer to connect to.\nldapPort: 636 The ldap port. Usually 636 for encrypted connections and 389 for unencrypted.\ninsecure: false Don\u0026rsquo;t use TLS.\nldapUser: \u0026quot;\u0026quot; Username to perform the ldap bind. For Active Directory domains, \u0026lt;user\u0026gt;@\u0026lt;domain.fqdn\u0026gt;.\nldapPass: \u0026quot;\u0026quot; The user\u0026rsquo;s password.\ntcpports: [\u0026quot;top25\u0026quot;] List of TCP ports to scan. Supports enumerations ([20,21,22,23]), ranges ([8000-8100]) or nmap-style top-lists (e.g. [\u0026quot;top50\u0026quot;]). You may also mix, e.g. [20,21,22,23,8000-8100,\u0026quot;top50\u0026quot;]. Duplicates are filtered out udpports: [\u0026quot;top25\u0026quot;] List of UDP ports to scan. Supports enumerations ([20,21,22,23]), ranges ([8000-8100]) or nmap-style top-lists (e.g. [\u0026quot;top50\u0026quot;]). You may also mix, e.g. [20,21,22,23,8000-8100,\u0026quot;top50\u0026quot;]. Duplicates are filtered out blacklist: [] A list of targets not to scan. May be CIDR networks, IPs or domain names.\nDNS resolution happens at the node and there is no reverse DNS lookup. This has important implications. For example, consider example.local resolving to 10.10.10.10. When blacklisting example.local but scanning for 10.10.10.0/24, the server is going to be scanned. When blacklisting 10.10.10.0/24 but scanning for example.local, the server is going to be scanned.\n maxHostsPerBatch: 150 Specifies how many target hosts are contained in a single work batch sent to a node. The higher the number, the more hosts have to be scanned by a single node before fetching new work. Should be tweaked together with maxTcpPortsPerBatch and maxUdpPortsPerBatch as well as depending on the actual requirements. You may take a look at A note on work scheduling.\nmaxTcpPortsPerBatch: 25 Specifies how many TCP ports are scheduled for a single work batch. The higher the number, the more TCP ports are scanned (if requested) before fetching new work. Should be tweaked together with maxHostsPerBatch and maxUdpPortsPerBatch as well as depending on the actual requirements. You may take a look at A note on work scheduling.\nmaxUdpPortsPerBatch: 25 Specifies how many UDP ports are scheduled for a single work batch. The higher the number, the more UDP ports are scanned (if requested) before fetching new work. Should be tweaked together with maxHostsPerBatch and maxTcpPortsPerBatch as well as depending on the actual requirements. You may take a look at A note on work scheduling.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/basic-settings/",
	"title": "Basic settings",
	"tags": [],
	"description": "",
	"content": "Top level configuration options debug: false Enables debug output server side.\nlisten: [8601] The port to listen on. Multiple ports may be specified, e.g. listen: [22, 80, 443, 3389] to listen on ports 22, 80, 443 and 3389. This may make it easier for you to operate a server with nodes in different networks and firewall policies.\nhost: \u0026quot;127.0.0.1\u0026quot; The address to listen on. \u0026quot;0.0.0.0\u0026quot; listens on all interfaces whereas \u0026quot;127.0.0.1\u0026quot; only listens on the loopback interface. IPv6 may work, too, but this is has not been tested yet.\nstatusPrintInterval: 15s Defines how often a status line is printed.\npools: 1 Configures the number of pools. Please refer to pooling for more information.\nconsiderClientPoolPreference: true Clients may request to be placed in a specific pool. This is required when nodes in a pool share specific properties, e.g. all nodes inside the same pool are in the same country.\nallowMultipleNodesPerHost: false This randomizes the nodeID, allowing to run multiple nodes on the same machine or in scenarios where no unique ID can be generated from the environment, for example container environments like Kubernetes. This is disabled by default because it is inconsistent with the environment information transmitted during node registration and makes it impossible to find out which node generated an event in the current implementation. Enabling this option does not break functionality and if nray is used on a single system or container cluster, the system that generated a specific event is probably of no interest. In scenarios where nray runs on a heterogeneous fleet, it may be relevant to track which system generated an event afterwards, so make sure to have this option disabled in those scenarios.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/",
	"title": "Configuration file (server)",
	"tags": [],
	"description": "",
	"content": "This section describes all configuration options of nray\u0026rsquo;s server configuration. The repository contains a default template that may be adapted.\nNray\u0026rsquo;s configuration is done with a yaml configuration file that has several subsections, depending on the internal submodule that is used. The documentation also describes the default values for all options.\n"
},
{
	"uri": "https://nray-scanner.org/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Nray is a sophisticated port scanner built from scratch.\nNray doesn\u0026rsquo;t require administrative permissions and runs dependency-less on nearly any architecture and operating system. Nevertheless, its scan speed is superior to Nmap in most cases while delivering nearly the same result quality regarding discovered ports.\nApart from that, nray introduces fresh ideas when it comes to target selection and result processing:\n Target selection:  IP, domain names and network lists - the usual stuff. Nray allows to observe the certificate transparency log and extract domain names from certificates issued nearly in real time. Nray can connect to LDAP (e.g. Active Directory) and perform arbitrary queries, e.g. obtain all registered computer objects and extract their FQDNs. DNS zone transfer planned.   Output  An event stream encoded as JSON data allows to search and use the results while the scan is still running. Native elasticsearch integration: Scan results are stored in your elasticsearch cluster as they arrive. Easily search and analyze the results of your network scans to gain valuable high-level insights. Splunk and metasploit planned.   Modularity: Want to integrate your CMDB or network inventory to nray? You prefer .csv output because it opens in Excel? Target selection and event processing is built in a modular way, therefore it should not be too hard for you to adapt nray to your requirements.  Nray allows to perform application layer scans for selected protocols, e.g. SSH or HTTP, using the ZGrab2 framework. The results are, of course, fully integrated into the event-based JSON result stream.\nAs mentioned, nray is designed as distributed network scanner. The server-client model allows to spin up an arbitrary number of nodes that perform a scan orchestrated by a server. This allows to scale scan speed linearly by introducing more nodes or to create network views by scanning from different vantage points.\nSounds too good? Give it a shot!\n"
},
{
	"uri": "https://nray-scanner.org/usage/flags/",
	"title": "Command line flags (node)",
	"tags": [],
	"description": "",
	"content": "Because nodes are going to deployed in a variety of scenarios in different environments, providing a configuration file is not viable. Most options are configured server side and transmitted when the node connects first, but at least the location and and connection settings (like TLS configuration) are required when a node is started.\nThe following options apply when nray runs as node (nray node):\n--debug Enable debug output.\n-h, --help Print a help message.\n--node-name \u0026lt;name\u0026gt; Assign a name to this scanning node. Useful if you are running multiple nodes and want to distinguish results in the event logs.\n-p, --port \u0026lt;port number\u0026gt;  Nray server port. Usually 8601.\n--preferred-pool \u0026lt;pool number\u0026gt; Pool to be preferably placed in at the server. If configured, the server respects this as long as the pool exists.\n-s, --server \u0026lt;server address or name\u0026gt; Nray server address.\n--tls-ca-cert \u0026lt;path\u0026gt; Path to ca certificate if TLS is used. Requires --use-tls.\n--tls-client-cert \u0026lt;path\u0026gt; Path to tls client cert. Requires --use-tls.\n--tls-client-key \u0026lt;path\u0026gt; Path to tls client key. Requires --use-tls.\n--tls-insecure Literally. Trust anybody. Don\u0026rsquo;t do this in networks you do not fully trust. Requires --use-tls.\n--tls-server-SAN \u0026lt;subject alternative name of server\u0026gt; Subject alternative name of the server. Go\u0026rsquo;s TLS implementation checks this value against the values provided in the certificate and refuses to connect if no match is found.\n--use-tls Set true to use TLS.\n"
},
{
	"uri": "https://nray-scanner.org/installation/",
	"title": "Installation",
	"tags": [],
	"description": "",
	"content": "Nray is written in Go and care was taken to select only dependencies that also fulfill this requirement. This allows to build completely static binaries that do not require any runtime dependencies. Furthermore, nray is designed for running as unprivileged user. Since Go supports a wide range of operating systems and architectures, it is possible to run nray on nearly any system with least user rights - the perfect solution to gain insight even into highly separated networks.\nTo sum it up: It is not required to install nray and it is supposed to run anywhere. Just drop and run the binary! There are prebuilt releases as well as instructions on building your own.\nOnce you obtained a binary for your environment, take a look at the usage section.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/tls/",
	"title": "TLS",
	"tags": [],
	"description": "",
	"content": "TLS If you are running nray in any other than your home network, make sure to enable TLS or you are going to have a bad time! If you don\u0026rsquo;t know what TLS is or don\u0026rsquo;t have a basic understanding of how these parameters play together, you should not run nray over untrusted networks!\n Nray relies on Golang, more specifically mangos, to provide support for TLS 1.2. TLS works with key material created by following the instructions of the TLS quick start guide.\nenabled: false Enables TLS. When operating nray over untrusted networks (like the Internet!), it is highly advised to protect the confidentially and integrity of the communication with nodes. Nray supports use of TLS 1.2, also with mutual authentication if required.\nCA: \u0026quot;\u0026quot; Path to the CA certificate.\ncert: \u0026quot;\u0026quot; Path to the server certificate.\nkey: \u0026quot;\u0026quot; Path to the server certificate private key.\nforceClientAuth: false If true, clients have to authenticate themselves with a certificate issued by a (sub-)CA.\n"
},
{
	"uri": "https://nray-scanner.org/installation/prebuilt/",
	"title": "Prebuilt Binaries",
	"tags": [],
	"description": "",
	"content": "Prebuilt binaries can be downloaded from the project\u0026rsquo;s Github page. Currently, binaries for the following operating systems and architectures are provided:\n Linux: x86, amd64, arm7 Windows: x86, amd64 macOS  Since nray is written in Go, you may (theoretically, untested) compile it to run on any of Go\u0026rsquo;s supported operating systems and architectures.\nIf you are missing a prebuilt architecture, need to inject your own custom configuration, just want a build from latest develop or have your own improvements applied, head over to the documentation on building from source.\n"
},
{
	"uri": "https://nray-scanner.org/installation/docker/",
	"title": "Docker",
	"tags": [],
	"description": "",
	"content": "Starting with 1.1, there are official Docker images and care is taken to support running nray from containered environments.\nRunning nray from Docker Nray\u0026rsquo;s source repository contains two Dockerfiles that are used to build the images also found on Docker Hub. The first one is based on Docker\u0026rsquo;s scratch image and since there is no user space apart from nray, it is really small. The second one builds upon Debian, giving the user the ability to access the system interactively which is often more desirable than having a small container.\nExample: Server In order to run a nray server from a container, a few precautions have to be taken:\n Make sure to bind to 0.0.0.0 inside the container (host: \u0026quot;0.0.0.0\u0026quot;), otherwise it is not possible to connect to the nray instance. Make sure to read configuration and write results to a directory that exists within the container and is mounted to the outside world. The images contain the directory /nray-data/ which is readable and writable for the nray user. In this example, /tmp/nray is mounted into the container - now, the nray process inside the container is able to read the configuration and if the output is configured to be written to /nray-data/, it can be read by the host.  A command that spawns a container running a nray server with respective directories mounted and ports forwarded may look like this:\ndocker run --rm --mount type=bind,src=/tmp/nray,dst=/nray-data -p 8601:8601 nrayscanner/nray-scratch server -c /nray-data/nray-conf.yaml Example: Node Compared to the server, nodes are a simple case since they are able to run without binding to ports or accessing the disk. Therefore, running a node can be as simple as:\ndocker run --rm nrayscanner/nray-debian node -s \u0026lt;server URL\u0026gt; -p \u0026lt;server port\u0026gt; Building nray docker containers Please refer to the Dockerfiles in the docker/ directory that can be found in the source repository. The creation of the images is done via the docker target in the Makefile.\nBuilding nray binaries from a docker container In order to build nray within a docker container, e.g. to avoid setting up a Go build environment on your own or because you are in a hurry and it is a one-liner, run the following command in the root of the nray source code repository:\ndocker run --rm -v \u0026#34;$PWD\u0026#34;:/nray -w /nray golang:latest make release If you are only interested in binaries for a specific architecture, you may alter the make target from release to any other supported value, e.g. build-x64-windows.\n"
},
{
	"uri": "https://nray-scanner.org/installation/build-your-own/",
	"title": "Build Your Own",
	"tags": [],
	"description": "",
	"content": "Want to build your own? Great, that\u0026rsquo;s the spirit! If you know git and command line basics, it isn\u0026rsquo;t too hard, promised! Quick and easy  First, you need git and Go installed. Once they are in place, clone the nray repository and check out the desired branch. Official releases are built from master whereas the hot new stuff is located in develop or feature branches. Open a terminal, navigate to the checked out folder and run go get -u followed by go build That\u0026rsquo;s it! You just built a nray binary for your system without any obvious magic involved!  Taking a closer look Usually it is easy to build a binary that runs on the current system, therefore this is no unique selling point. Go\u0026rsquo;s ability to generate binaries for most operating systems and architecture without requiring third party libraries (like glibc!) as well as the excellent cross-compiling capabilities were a main reason for choosing this language. It also supports injecting values for variables at compile time which comes in handy in some situations.\nIn order to understand what is going on, we are going to look at an excerpt of the actual Makefile. Fear not, this is not the kind of complex Makefile you may have seen in the past as the build process for nray is quite simple and straight-forward.\nIn this example, we are going to look at the (slightly simplified) build-armv7-linux and build-localarch targets:\nbuild-armv7-linux: CGO_ENABLED=0 GOOS=linux GOARCH=arm GOARM=7 go build -ldflags \u0026#34;-s -w\u0026#34; -o build/nray-armv7-linux ./nray.go  CGO_ENABLED=0: Disables CGO, in other words: Make sure no C-code is used or linked. On some platforms, the Go-compiler may prefer existing C code for some functionality which decreases portability. We explicitly disable this behavior to make sure the binary is going to run on the target regardless of availability of specific libraries like glibc. GOOS=linux: Build a linux binary GOARCH=arm: The target architecture is ARM GOARM=7: Specifically: ARMv7 go build -o build/nray-armv7-linux ./nray.go: Take nray.go and compile it to build/nray-armv7-linux -ldflags \u0026quot;-s -w\u0026quot;: Omits symbol tables and debug information. This mostly reduces the size of the binary but should be disabled first when tracking down bugs.  That\u0026rsquo;s it. No fighting the cross compiler or installing dependencies for ARM. build-localarch introduces more cool features, especially for developing nray or running in constrained environments:\nbuild-localarch: go build -race -o build/nray ./nray.go go build -race -ldflags \u0026#34;-X main.server=127.0.0.1 -X main.port=8601\u0026#34; -o build/nray_localhardcoded ./nray.go This target creates two binaries: nray and nray_localhardcoded. Both are targeting the architecture and operating system of the build machine. CGO is not disabled in order to use the race detector of Go. The race detector is a really powerful feature that allows to detect concurrent, not synchronized access to data. Since nray heavily depends on Go\u0026rsquo;s concurrency features, the race detector is probably the main reason why nray does not blow up every ten seconds, so if you\u0026rsquo;re working on the code base it is highly advised to enable it.\nIn contrast to the nray binary, nray_localhardcoded has values for the server and port address injected at compile time. Running nray_localhardcoded without any parameters (e.g. by double clicking) will connect to 127.0.0.1:8601 which may come in handy in some situations "
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/internal/",
	"title": "Internal",
	"tags": [],
	"description": "",
	"content": "internal Everything called internal is\u0026hellip; well internal and you should only change it if you know what you are doing. This also applies to internal objects exposed by other configuration nodes.\n nodeExpiryTime: 30s Timeout to expire nodes that did not send heart beats.\nnodeExpiryCheckInterval: 10s How often to check for expired nodes.\n"
},
{
	"uri": "https://nray-scanner.org/usage/pooling/",
	"title": "Pooling",
	"tags": [],
	"description": "",
	"content": "The core concept around nray\u0026rsquo;s work distribution functionality is pooling.\nNray internally has a list of pools, how many can be specified via the pools: n directive in the configuration file. The idea is that each pool performs a scan of all targets, which means that each pool creates a complete view. Each pool may contain an arbitrary number of scanner nodes that work together on performing the scan.\nThis means that speeding up a scan by bringing more workers in is achieved by placing them all in the same pool whereas creation of network views is done by creating a pool for each desired view.\nIn it\u0026rsquo;s default configuration, nray only has a single pool and currently pools don\u0026rsquo;t support names, so they are numbered starting with 0. In case multiple pools are available, nray is going to place new nodes in the pool with fewest members. In order to manually control which pool a node should be assigned to, set considerClientPoolPreference: true in the nray configuration and start the nodes with --preferred-pool x. For example, if you want to connect a node to a server and place it into pool 2, you may run the following command: nray node -s \u0026lt;server ip\u0026gt; -p \u0026lt;server port\u0026gt; --preferred-pool 2.\n"
},
{
	"uri": "https://nray-scanner.org/usage/",
	"title": "Usage",
	"tags": [],
	"description": "",
	"content": "Nray tries to be easy to understand and use - nevertheless, you may take a few minutes to skim the documentation to understand differences to other scanners. In contrast to most other port scanners, nray is designed to allow multiple scanning nodes to conduct the scan, therefore achieving better results regarding speed and result accuracy. The nray binary can act as server, managing all connected nodes, generating work, distributing the scan tasks and collecting results, or, as node, perform the hard work delegated by an other nray server instance.\nNearly all configuration is done server side in a configuration file. The are no command line flags for most options - configuration files prevent script wrappers, are easier to read/write, can be kept in source control systems and you can comment them so others understand the rationale behind your configuration. If you are new to nray, you may want to start by adopting the configuration file template while looking up configuration options before changing them.\nStart server nray server -c \u0026lt;/path/to/config.yml\u0026gt; Start node(s) nray node -s \u0026lt;server-ip-or-domain-name\u0026gt; -p \u0026lt;port\u0026gt; "
},
{
	"uri": "https://nray-scanner.org/contribute/",
	"title": "Contribute",
	"tags": [],
	"description": "",
	"content": "Nray was written to close gaps other tools did not address. It is free software and hopefully serves you well. There are no companies or financial resources involved and the complete development happened in spare time during weekends and evenings.\nThere may be many bugs to fix, tests to write and features to implement. This page gives an overview on how to improve nray to make it a robust port scanner everybody likes to use in the daily workflow.\n Improve documentation. Sentences aren\u0026rsquo;t clear, examples missing, you have a better explanation? You can edit each page of the documentation with a few clicks. Once done, send a pull request and after a review, your changes are probably going to be merged and go live. Find bugs, open issues. This is probably the most common way to participate: Find the corner cases and usage scenarios breaking nray\u0026rsquo;s functionality. Opening issues does not get work done, so the next step is to clone the repository and start fixing issues or implementing new functionality. The project\u0026rsquo;s Github page has more information on how to get started with development. Write tests, review pull requests, help to restructure and refactor code in a way to keep nray maintainable and extensible. Spread the word: Write blog posts, share success stories, tell your friends and colleagues.  "
},
{
	"uri": "https://nray-scanner.org/usage/tls-setup/",
	"title": "TLS setup",
	"tags": [],
	"description": "",
	"content": "It is recommended to use TLS for protecting traffic between nray\u0026rsquo;s server and nodes, including mutual authentication if required. This quick start guide describes a portable and working approach to generate a CA and all required keys and certificates as well as how to use them. The goal is to provide an easy to follow guide, nevertheless a basic understanding of TLS and PKI is recommended.\nThis guide relies on cloudflare\u0026rsquo;s open source cfssl. Cherry-picked from here and here and here and of course here.\nIf you manage to get this up and running using keys and certificates generated by OpenSSL, Microsoft PKI, vim macro or your favorite solution not listed yet, we would love to know how you did it - simply edit this page and send a pull request!\nCFSSL: Generate local CA, keys and certificates Get cfssl: go get -u github.com/cloudflare/cfssl/cmd/cfssl and go get -u github.com/cloudflare/cfssl/cmd/cfssljson Generate a CSR and save it to a file, e.g. csr.json. It contains basic information about the CA:  { \u0026#34;key\u0026#34;: { \u0026#34;algo\u0026#34;: \u0026#34;rsa\u0026#34;, \u0026#34;size\u0026#34;: 2048 }, \u0026#34;names\u0026#34;: [ { \u0026#34;C\u0026#34;: \u0026#34;DE\u0026#34;, \u0026#34;L\u0026#34;: \u0026#34;Munich\u0026#34;, \u0026#34;O\u0026#34;: \u0026#34;nray-scanner\u0026#34; } ] } Generate a local CA: cfssl genkey -initca csr.json | cfssljson -bare ca. This creates ca-key.pem, the CA\u0026rsquo;s private key, as well as ca.pem, the certificate and ca.csr which is of no further use and may be deleted. Generate server certificate. If the host where nray is going to run has a DNS name, you may include it here, otherwise keep localhost: cfssl gencert -ca ca.pem -ca-key ca-key.pem -hostname=localhost csr.json | cfssljson -bare server. This creates files analogous to our CA, but with server* in their names. (if node auth is desired) Generate node certificate. Analogous to server. You may omit the hostname field and ignore the warning. Repeat for every node or reuse certificate.  As you do not need the csr\u0026rsquo;s anymore, you may delete them if you want.\nWhat you need for operation Server  ca.pem (This is public knowledge btw) server.pem (public if you want) server-key.pem (private)  Node  ca.pem (This is public knowledge btw) client.pem (public if you want) client-key.pem (private)  HowTo run Trust every server, no client auth  Server: Set TLS.enabled: true, TLS.CA: \u0026quot;/path/to/your/ca.pem\u0026quot;, TLS.cert: /path/to/your/server.pem, and TLS.key: /path/to/your/server-key.pem Node: ./nray node -s \u0026lt;ip-or-dnsname\u0026gt; -p 8601 --use-tls --tls-insecure. This is insecure and traffic may be intercepted/modified by a 3rd party!. This mode of operation only protects from somebody occasionally scrolling over the traffic in Wireshark.  Trust only this server, no client auth  Server: Set TLS.enabled: true, TLS.CA: \u0026quot;/path/to/your/ca.pem\u0026quot;, TLS.cert: /path/to/your/server.pem, and TLS.key: /path/to/your/server-key.pem Node: ./nray node -s \u0026lt;ip-or-dnsname\u0026gt; -p 8601 --use-tls --tls-ca-cert /path/to/your/ca.pem --tls-server-SAN \u0026quot;\u0026lt;hostname\u0026gt;\u0026quot;. If the nray-server has actually a DNS name that is also reflected in the cert, you can omit --tls-server-SAN, but if you are in an ad-hoc scenario or there is no DNS available and nray complains that the server name is missing, --tls-server-SAN is your friend.  Trust only this server, client authentication  Server: Set TLS.enabled: true, TLS.CA: \u0026quot;/path/to/your/ca.pem\u0026quot;, TLS.cert: /path/to/your/server.pem, and TLS.key: /path/to/your/server-key.pem Node: ./nray-node -s \u0026lt;ip-or-dnsname\u0026gt; -p 8601 --use-tls --tls-ca-cert /path/to/your/ca.pem --tls-server-SAN \u0026quot;\u0026lt;hostname\u0026gt;\u0026quot; --tls-client-cert /path/to/your/client.pem --tls-client-key /path/to/your/client-key.pem. If the nray-server has actually a DNS name that is also reflected in the cert, you can omit --tls-server-SAN, but if you are in an ad-hoc scenario or there is no DNS available and nray complains that the server name is missing, --tls-server-SAN is your friend.  "
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/targetgenerator/",
	"title": "targetgenerator",
	"tags": [],
	"description": "",
	"content": "Everything that produces a stream of targets that need to be scanned is a target generator. Due to the modular design, it should be easy to implement your own generators from your data sources.\nbufferSize: 5 Size of the work batch buffer. If you are planning to have a lot of nodes or a lossy data input stream, you may increase this number, otherwise it simply consumes a little bit more memory.\nA note on work scheduling Understanding how nray schedules work may allow you to greatly improve performance. In order to explain the inner workings in greater detail, take a look at following configuration of the standard target generator:\ntargets: [\u0026#34;10.0.0.0/22\u0026#34;] tcpports: [\u0026#34;top500\u0026#34;] udpports: [\u0026#34;\u0026#34;] maxHostsPerBatch: 150 maxTcpPortsPerBatch: 25 In this case, the network consists of about 1000 hosts to scan for the 500 most common TCP ports. In order to distribute this task across nodes, nray chops it into pieces, so called work batches that are requested and processed by nodes. In this case, each batch is going to contain a list of 150 hosts and 25 TCP ports that have to be scanned on these hosts. In order to scan all hosts, 7 batches would be enough, but there is also the port restriction. Each batch must not contain more than 25 ports, therefore 20 batches are required to scan all TCP ports for a single host group. In the end, 7 * 20 = 140 batches are created for the above configuration.\nIn case for example only ports 22, 80 and 443 are of interest, you may scale up maxHostsPerBatch whereas if you only want to scan a few hosts but on a large number of ports, you may advise nray to create batches containing only one or two hosts, but for example 10000 ports.\nA good rule of thumb is to find a configuration such that nodes call back for more work every ~15-20 seconds - this gives you results often and fast and in case a node gets lost, fewer work has to be rescheduled.\n"
},
{
	"uri": "https://nray-scanner.org/usage/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "This page contains some examples to get your nray experience started quickly.\nAll examples assume that the binary is called nray, of course you have to adapt this to the name of your binary.\nSimple port scan from local machine Unfortunately, due to a bug in the upstream project of the configuration parser, currently some options mustn\u0026rsquo;t be omitted. See this issue for more information. The following configuration has therefore all options listed, albeit most of them are disabled. The relevant settings are marked with a comment.\n  Edit the configuration file (e.g. config.yaml) to contain the following:  debug: false listen: [8601] # Port to listen host: \u0026#34;127.0.0.1\u0026#34; # host to listen (only localhost) pools: 1 # Only use a single pool TLS: enabled: false CA: \u0026#34;/path/to/ca.pem\u0026#34; cert: \u0026#34;/path/to/servercert.pem\u0026#34; key: \u0026#34;/path/to/servercert-key.pem\u0026#34; forceClientAuth: false considerClientPoolPreference: true allowMultipleNodesPerHost: false internal: nodeExpiryTime: 30 nodeExpiryCheckInterval: 10 targetgenerator: bufferSize: 5 standard: enabled: true targets: [\u0026#34;192.168.178.1/28\u0026#34;] # target network to scan tcpports: [\u0026#34;top25\u0026#34;] # which TCP ports to scan udpports: [] # don\u0026#39;t scan UDP blacklist: [] # no blacklist maxHostsPerBatch: 20 maxTcpPortsPerBatch: 25 maxUdpPortsPerBatch: 25 certificatetransparency: enabled: false domainRegex: \u0026#39;^(www[.]).*([.]com)$\u0026#39; tcpports: [top25] udpports: [top25] blacklist: [] maxHostsPerBatch: 150 maxTcpPortsPerBatch: 25 maxUdpPortsPerBatch: 25 ldap: enabled: false ldapSearchString: \u0026#34;(objectCategory=computer)\u0026#34; baseDN: \u0026#34;dc=contoso,dc=com\u0026#34; ldapAttribute: \u0026#34;dNSHostName\u0026#34; ldapServer: \u0026#34;\u0026#34; ldapPort: 636 insecure: false ldapUser: \u0026#34;\u0026#34; ldapPass: \u0026#34;\u0026#34; tcpports: [top25] udpports: [top25] blacklist: [] maxHostsPerBatch: 5 maxTcpPortsPerBatch: 25 maxUdpPortsPerBatch: 25 scannerconfig: workers: 250 # Run with 250 workers ratelimit: \u0026#34;none\u0026#34; # No rate limit tcp: timeout: 2500ms # 2.5s TCP timeout udp: fast: false defaultHexPayload: \u0026#34;\\x6e\\x72\\x61\\x79\u0026#34; timeout: 2500ms zgrab2: enabledModules: [] ssh: subscribePorts: [\u0026#34;tcp/22\u0026#34;] timeout: 2500ms ClientID: \u0026#34;SSH-2.0-Go-nray\u0026#34; CollectUserAuth: true http: subscribeHTTPPorts: [\u0026#34;tcp/80\u0026#34;, \u0026#34;tcp/8080\u0026#34;, \u0026#34;tcp/8000\u0026#34;] subscribeHTTPSPorts: [\u0026#34;tcp/443\u0026#34;, \u0026#34;tcp/8443\u0026#34;] timeout: 2500ms method: \u0026#34;GET\u0026#34; endpoint: \u0026#34;/\u0026#34; userAgent: \u0026#34;nray\u0026#34; retryHTTPS: true maxRedirects: 2 events: terminal: enabled: true # print events to terminal internal: channelsize: 1000 json-file: enabled: true # write events to file filename: \u0026#34;nray-output.json\u0026#34; # filename overwriteExisting: false internal: channelsize: 10000 synctimer: 10s elasticsearch: enabled: false server: \u0026#34;elasticsearch.local\u0026#34; useTLS: true port: 443 internal: indexname: \u0026#34;nray\u0026#34; channelsize: 10000 committimer: 3  Next, run the server: ./nray server -c /path/to/config.yaml. Finally, run a node on the same system: ./nray node. If no server and port is specified, nodes always try to connect to localhost:8601 whereas other values can be injected at compile time or can be passed via -s \u0026lt;server\u0026gt; and -p \u0026lt;port\u0026gt; parameter. If there are systems in the network having ports opened, you should now see events for each port found. Results are also written to nray-output.json  jq library jq is an excellent command line JSON processor. It allows to view and query JSON documents and you may give it a shot for accessing the event file.\nFor live viewing, jq -C '\u0026lt;expr\u0026gt;' \u0026lt;outputfile\u0026gt; | less -R gives you scrollable, colorized output. During a scan, you can also tail -f \u0026lt;outputfile\u0026gt; | jq '\u0026lt;expr\u0026gt;'.\n Here are some example queries to get you started:\nShow all events where port 22 was involved jq \u0026#39;. | select(.result.port == 22)\u0026#39; \u0026lt;outputfile\u0026gt; This includes TCP, UDP and ZGrab2 events.\nShow all events where tcp port 80 was found open jq \u0026#39;. | select(.result.portscan.port == 80 and .result.portscan.open == true and .result.portscan.scantype == \u0026#34;tcpconnect\u0026#34;)\u0026#39; \u0026lt;outputfile\u0026gt; Actually, the result.portscan.open can be omitted since closed ports do not generate events.\nShow only IPs/names of systems where tcp port 80 was found open jq \u0026#39;. | select(.result.portscan.port == 80 and .result.portscan.open == true and .result.portscan.scantype == \u0026#34;tcpconnect\u0026#34;) | .result.target\u0026#39; \u0026lt;outputfile\u0026gt; "
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/scannerconfig/",
	"title": "scannerconfig",
	"tags": [],
	"description": "",
	"content": "workers: 250 How many asynchronous workers to spawn. There are operating system restrictions to the number of open file descriptors of a process, e.g. 1024 on most modern Linux distributions. Since some of them are required for internal usage (e.g. communication with server), from experience 1000 is pretty much the best you may get on x64_linux whereas different limits may apply on other operating systems / architectures.\nratelimit: \u0026quot;none\u0026quot; A rate limit can be set to control how many workers start their scan within a second. This becomes handy to avoid bursts with many workers where scans have long durations / timeouts, e.g. a scan having a timeout of 10 seconds with 1000 workers may be throttled to 100 workers starting their scan each second (instead of all at the beginning) by setting ratelimit: 100.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/scannerconfig/tcp/",
	"title": "tcp",
	"tags": [],
	"description": "",
	"content": "timeout: 2500ms Timeout for TCP connections. If no response is received within this time frame, a port is marked closed.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/scannerconfig/udp/",
	"title": "udp",
	"tags": [],
	"description": "",
	"content": "fast: false Fast sends only known payloads to known ports. The list and payloads are taken from the Metasploit project and it contains currently UDP ports 1604, 53, 137, 123, 524, 5093, 1434, 161, and 111.\ndefaultHexPayload: \u0026quot;\\x6e\\x72\\x61\\x79\u0026quot; Since UDP is connection-less, a payload needs to be sent. This option configures the default payload that is sent if no custom payload is specified for a port. ASCII is supported as well as hexadecimal and octal data representation. \\x6e\\x72\\x61\\x79 is hexadecimal for nray.\ncustomHexPayloads:  Allows to specify custom payloads for specific ports. The example below sends a single 'A' character to udp/19:\ncustomHexPayloads: \u0026#34;19\u0026#34;: \u0026#34;A\u0026#34; # chargen. \u0026#34;A\u0026#34; is the same as \u0026#34;\\x41\u0026#34; (hex) or \u0026#34;\\101\u0026#34; (oct) timeout: 2500ms Timeout for UDP. If no response is received within this time frame, a port is marked closed.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/scannerconfig/zgrab2/",
	"title": "zgrab2",
	"tags": [],
	"description": "",
	"content": " ZGrab2 integration is experimental and porting is currently not complete. You can help adding modules and improve stability.\n ZGrab2 is an awesome application layer scanner. Since it is supposed to run standalone and doesn\u0026rsquo;t provide an API, integration into nray requires some glue code for each module to work.\nNray\u0026rsquo;s ZGrab2 integration uses a subscription-based approach for performing application layer scans. Suppose the following configuration:\nssh: subscribePorts: [\u0026#34;tcp/22\u0026#34;, \u0026#34;tcp/222\u0026#34;, \u0026#34;tcp/2222\u0026#34;] timeout: 2500ms Here, an SSH application layer scan with its own timeout of 2500ms is triggered every time an open port tcp/22, tcp/222, or tcp/2222 is found.\nNray\u0026rsquo;s ZGrab2 integration runs also concurrent to other scans, using the worker pools and rate limits assigned in the scanner configuration. The result produced are also in JSON format and fit into the events produced by nray\u0026rsquo;s port scanning functionality.\nenabledModules: [] Which ZGrab2 modules to enable. Currently, the following modules are supported:\n SSH HTTP (includes HTTPS and various TLS checks)  "
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/scannerconfig/zgrab2/ssh/",
	"title": "ssh",
	"tags": [],
	"description": "",
	"content": " ZGrab2 integration is experimental and porting is currently not complete. You can help adding modules and improve stability.\n subscribePorts: [\u0026quot;tcp/22\u0026quot;] Ports to subscribe. If one of these is found open, this scanner module is triggered against that target.\ntimeout: 2500ms Timeout before the scan is cancelled.\nClientID: \u0026quot;SSH-2.0-Go-nray\u0026quot; SSH client ID to present to the server.\nCollectUserAuth: true If set to true, possible client authentication options are queried.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/scannerconfig/zgrab2/http/",
	"title": "http",
	"tags": [],
	"description": "",
	"content": " ZGrab2 integration is experimental and porting is currently not complete. You can help adding modules and improve stability.\n The naming of this module\u0026rsquo;s subscription parameters differ from other ZGrab2 modules due to the need to differentiate between HTTP and HTTPS.\n subscribeHTTPPorts: [\u0026quot;tcp/80\u0026quot;, \u0026quot;tcp/8080\u0026quot;, \u0026quot;tcp/8000\u0026quot;] Ports to subscribe for HTTP scanning. If one of these is found open, the HTTP scanner module is triggered against that target.\nsubscribeHTTPSPorts: [\u0026quot;tcp/443\u0026quot;, \u0026quot;tcp/8443\u0026quot;] Ports to subscribe for HTTPS scanning. If one of these is found open, the HTTPS scanner module is triggered against that target.\ntimeout: 2500ms Timeout before the scan is cancelled.\nmethod: \u0026quot;GET\u0026quot; HTTP method to use.\nendpoint: \u0026quot;/\u0026quot; HTTP endpoint to request.\nuserAgent: \u0026quot;nray\u0026quot; User Agent to send with the HTTP requests.\nretryHTTPS: true In case a HTTP connection fails, HTTPS is tried if this option is set to true.\nmaxRedirects: 2 How many redirects to follow before giving up.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/events/",
	"title": "events",
	"tags": [],
	"description": "",
	"content": "Filtering All event handlers support filtering of events. This is especially useful if particular events are of special interest, e.g. specific open ports.\nThe configuration option to enable filtering for an event handler is called filter and has the name of the JSON fields as options.\nThe following example example of the terminal filter prints all events of type environment or where portscan.port is 25:\nevents: terminal: enabled: true # Any matching filter is going to be printed filter: environment: # empty filter is printed if a element of this type exists result.port: 25 # All port 25 events, regardless of scanning module.  internal: channelsize: 1000 In this case, this is only applied to the terminal event handler - but filtering works the same way for other event handlers, too.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/events/terminal/",
	"title": "terminal",
	"tags": [],
	"description": "",
	"content": "enabled: true Enables printing of events to stdout.\ninternal.channelsize: 1000 Size of the internal channel holding events.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/events/json-file/",
	"title": "json-file",
	"tags": [],
	"description": "",
	"content": "enabled: true Enables logging of events to a file.\nfilename: \u0026quot;nray-output.json\u0026quot; The filename to log to.\noverwriteExisting: false If set to false, this option prevents from (accidentally) overwriting existing output files.\ninternal.channelsize: 10000 Size of the internal buffer holding events between force flushing to file system.\ninternal.synctimer: 10s Interval to flush data to the file system.\n"
},
{
	"uri": "https://nray-scanner.org/usage/configuration-file/events/elasticsearch/",
	"title": "elasticsearch",
	"tags": [],
	"description": "",
	"content": "enabled: false Enables the elasticsearch event handler. If true, all events are also sent to elasticsearch. This is useful for performing queries or visualizing data, e.g. using Kibana.\nserver: \u0026quot;elasticsearch.local\u0026quot; The name or IP address of the elasticsearch node.\nuseTLS: true Forces use of TLS.\nport: 443 TCP port elasticsearch is listening on.\ninternal.indexname: \u0026quot;nray\u0026quot; The name of the index.\ninternal.channelsize: 10000 Size of the internal buffer holding events between commits.\ninternal.committimer: 3 Interval to commit data.\n"
},
{
	"uri": "https://nray-scanner.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://nray-scanner.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]